package com.oxleya.malwareconnector.processor;

import com.oxleya.malwareconnector.file_type.data.BaseEntity;
import com.oxleya.malwareconnector.file_type.data.PdfFile;
import com.oxleya.malwareconnector.file_type.repository.PdfFileRepository;
import com.oxleya.malwareconnector.similarity.FuzzyHashSimilarityService;
import org.apache.commons.lang3.StringUtils;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.PDDocumentNameDictionary;
import org.apache.pdfbox.pdmodel.PDEmbeddedFilesNameTreeNode;
import org.apache.pdfbox.pdmodel.common.PDNameTreeNode;
import org.apache.pdfbox.pdmodel.common.filespecification.PDComplexFileSpecification;
import org.apache.pdfbox.text.PDFTextStripper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.integration.annotation.ServiceActivator;
import org.springframework.messaging.handler.annotation.Header;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static com.oxleya.malwareconnector.file_type.data.BaseEntity.SIMILARITY_REASON_AUTHOR;
import static com.oxleya.malwareconnector.file_type.data.BaseEntity.SIMILARITY_REASON_CREATOR;
import static com.oxleya.malwareconnector.file_type.data.BaseEntity.SIMILARITY_REASON_FUZZY_HASH;
import static com.oxleya.malwareconnector.gateway.PushFileForProcessingGateway.PARENT_ID;

@Service
public class PdfProcessor {

    private static final Logger LOGGER = LoggerFactory.getLogger(PdfProcessor.class);
    public static final String PDF_PROCESSING_CHANNEL = "pdfProcessingChannel";

    @Resource
    private PdfAttachmentProcessor pdfAttachmentProcessor;

    @Resource
    private PdfFileRepository pdfFileRepository;

    @ServiceActivator(inputChannel = PDF_PROCESSING_CHANNEL, outputChannel = "nullChannel")
    public void processPdf(PDDocument pdf, @Header(value = PARENT_ID, required = false) Long parentFileId) {
        PdfFile pdfFile = generatePdfFileObject(pdf);
        findSimilarities(pdfFile);
        pdfFile = pdfFileRepository.save(pdfFile, parentFileId);
        pushEmbeddedFilesForProcessing(pdf, pdfFile.getId());
    }

    private PdfFile generatePdfFileObject(PDDocument pdf) {
        final PdfFile pdfFile = new PdfFile();
        pdfFile.setText(getTextFromPdf(pdf));
        pdfFile.setFuzzyHashOfText(FuzzyHashSimilarityService.generateFuzzyHash(pdfFile.getText()));
        pdfFile.setAuthor(pdfFile.getAuthor());
        pdfFile.setCreationDate(pdfFile.getCreationDate());
        pdfFile.setCreator(pdfFile.getCreator());
        pdfFile.setProducer(pdfFile.getProducer());
        pdfFile.setSubject(pdfFile.getSubject());
        pdfFile.setTitle(pdfFile.getTitle());
        return pdfFile;
    }

    private String getTextFromPdf(PDDocument pdf) {
        try {
            final PDFTextStripper textStripper = new PDFTextStripper();
            return textStripper.getText(pdf);
        } catch (IOException e) {
            LOGGER.warn("There was an issue extracting text from the pdf.");
        }
        return null;
    }

    private void findSimilarities(PdfFile pdfFile) {
        findSimilaritiesViaFuzzyHash(pdfFile);
        findSimilaritiesViaAuthor(pdfFile);
        findSimilaritiesViaCreator(pdfFile);
    }

    private void findSimilaritiesViaFuzzyHash(PdfFile pdfFile) {
        List<PdfFile> allSavedPdfs = (List<PdfFile>) pdfFileRepository.findAll();
        final Map<Long, String> hashes = allSavedPdfs.stream().collect(Collectors.toMap(PdfFile::getId, PdfFile::getFuzzyHashOfText));
        List<Long> idsOfSimilarPdfFiles = FuzzyHashSimilarityService.areSimilar(pdfFile.getText(), hashes);
        for (PdfFile savedPdf : allSavedPdfs) {
            if (idsOfSimilarPdfFiles.contains(savedPdf.getId())) {
                pdfFile.linkToSimilarNode(savedPdf, SIMILARITY_REASON_FUZZY_HASH);
            }
        }
    }

    private void findSimilaritiesViaAuthor(PdfFile pdfFile) {
        if (StringUtils.isNotEmpty(pdfFile.getAuthor())) {
            List<PdfFile> allSavedPdfs = (List<PdfFile>) pdfFileRepository.findAll();
            List<Long> idsOfSimilarPdfFiles = allSavedPdfs.stream()
                    .filter(pdf -> StringUtils.equalsIgnoreCase(pdf.getAuthor(), pdfFile.getAuthor()))
                    .map(PdfFile::getId)
                    .collect(Collectors.toList());
            for (PdfFile savedPdf : allSavedPdfs) {
                if (idsOfSimilarPdfFiles.contains(savedPdf.getId())) {
                    pdfFile.linkToSimilarNode(savedPdf, SIMILARITY_REASON_AUTHOR);
                }
            }
        }
    }

    private void findSimilaritiesViaCreator(PdfFile pdfFile) {
        if (StringUtils.isNotEmpty(pdfFile.getCreator())) {
            List<PdfFile> allSavedPdfs = (List<PdfFile>) pdfFileRepository.findAll();
            List<Long> idsOfSimilarPdfFiles = allSavedPdfs.stream()
                    .filter(pdf -> StringUtils.equalsIgnoreCase(pdf.getCreator(), pdfFile.getCreator()))
                    .map(PdfFile::getId)
                    .collect(Collectors.toList());
            for (PdfFile savedPdf : allSavedPdfs) {
                if (idsOfSimilarPdfFiles.contains(savedPdf.getId())) {
                    pdfFile.linkToSimilarNode(savedPdf, SIMILARITY_REASON_CREATOR);
                }
            }
        }
    }

    /**
     * This will try to extract out any embedded files. Logic derived from
     * https://memorynotfound.com/apache-pdfbox-extract-embedded-file-pdf-document/
     * @param pdf
     * @param pdfParentId
     */
    private void pushEmbeddedFilesForProcessing(PDDocument pdf, Long pdfParentId) {
        PDDocumentNameDictionary namesDictionary = new PDDocumentNameDictionary(pdf.getDocumentCatalog());
        PDEmbeddedFilesNameTreeNode efTree = namesDictionary.getEmbeddedFiles();
        if (efTree != null) {
            Map<String, PDComplexFileSpecification> names = null;
            try {
                names = efTree.getNames();
            } catch (IOException e) {
                LOGGER.warn("Issue trying to extract the names of embedded files in the pdf.");
            }
            if (names != null) {
                extractFiles(names, pdfParentId);
            } else {
                List<PDNameTreeNode<PDComplexFileSpecification>> kids = efTree.getKids();
                for (PDNameTreeNode<PDComplexFileSpecification> node : kids) {
                    try {
                        names = node.getNames();
                    } catch (IOException e) {
                        LOGGER.warn("Unable to extract out embedded file name from pdf.");
                    }
                    extractFiles(names, pdfParentId);
                }
            }
        }
    }

    private void extractFiles(Map<String, PDComplexFileSpecification> embeddedFiles, Long pdfParentId) {
        for (Map.Entry<String, PDComplexFileSpecification> entry : embeddedFiles.entrySet()) {
            PDComplexFileSpecification fileSpec = entry.getValue();
            String filename = fileSpec.getFile();
            pdfAttachmentProcessor.pushAttachmentForProcessing(entry.getValue(), pdfParentId);
        }
    }
}
